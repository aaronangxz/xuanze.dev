"use strict";(self.webpackChunkleetcode_notes=self.webpackChunkleetcode_notes||[]).push([[564],{3905:(t,o,e)=>{e.d(o,{Zo:()=>u,kt:()=>d});var n=e(7294);function i(t,o,e){return o in t?Object.defineProperty(t,o,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[o]=e,t}function r(t,o){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);o&&(n=n.filter((function(o){return Object.getOwnPropertyDescriptor(t,o).enumerable}))),e.push.apply(e,n)}return e}function m(t){for(var o=1;o<arguments.length;o++){var e=null!=arguments[o]?arguments[o]:{};o%2?r(Object(e),!0).forEach((function(o){i(t,o,e[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(o){Object.defineProperty(t,o,Object.getOwnPropertyDescriptor(e,o))}))}return t}function a(t,o){if(null==t)return{};var e,n,i=function(t,o){if(null==t)return{};var e,n,i={},r=Object.keys(t);for(n=0;n<r.length;n++)e=r[n],o.indexOf(e)>=0||(i[e]=t[e]);return i}(t,o);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)e=r[n],o.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}var l=n.createContext({}),s=function(t){var o=n.useContext(l),e=o;return t&&(e="function"==typeof t?t(o):m(m({},o),t)),e},u=function(t){var o=s(t.components);return n.createElement(l.Provider,{value:o},t.children)},p={inlineCode:"code",wrapper:function(t){var o=t.children;return n.createElement(n.Fragment,{},o)}},c=n.forwardRef((function(t,o){var e=t.components,i=t.mdxType,r=t.originalType,l=t.parentName,u=a(t,["components","mdxType","originalType","parentName"]),c=s(e),d=i,b=c["".concat(l,".").concat(d)]||c[d]||p[d]||r;return e?n.createElement(b,m(m({ref:o},u),{},{components:e})):n.createElement(b,m({ref:o},u))}));function d(t,o){var e=arguments,i=o&&o.mdxType;if("string"==typeof t||i){var r=e.length,m=new Array(r);m[0]=c;var a={};for(var l in o)hasOwnProperty.call(o,l)&&(a[l]=o[l]);a.originalType=t,a.mdxType="string"==typeof t?t:i,m[1]=a;for(var s=2;s<r;s++)m[s]=e[s];return n.createElement.apply(null,m)}return n.createElement.apply(null,e)}c.displayName="MDXCreateElement"},1719:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>l,contentTitle:()=>m,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>s});var n=e(7462),i=(e(7294),e(3905));const r={sidebar_position:1007},m="[WIP] 1007. Minimum Domino Rotations For Equal Row",a={unversionedId:"leetcode/medium/Minimum Domino Rotations For Equal Row",id:"leetcode/medium/Minimum Domino Rotations For Equal Row",title:"[WIP] 1007. Minimum Domino Rotations For Equal Row",description:"Question",source:"@site/docs/leetcode/medium/1007. Minimum Domino Rotations For Equal Row.md",sourceDirName:"leetcode/medium",slug:"/leetcode/medium/Minimum Domino Rotations For Equal Row",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Minimum Domino Rotations For Equal Row",tags:[],version:"current",sidebarPosition:1007,frontMatter:{sidebar_position:1007},sidebar:"lcSidebar",previous:{title:"946. Validate Stack Sequences",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Validate Stack Sequences"},next:{title:"1249. Minimum Remove to Make Valid Parentheses",permalink:"/XZ-LeetCode-Journal/docs/leetcode/medium/Minimum Remove to Make Valid Parentheses"}},l={},s=[{value:"Question",id:"question",level:2},{value:"Approach",id:"approach",level:2},{value:"Solution",id:"solution",level:2}],u={toc:s};function p(t){let{components:o,...e}=t;return(0,i.kt)("wrapper",(0,n.Z)({},u,e,{components:o,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"wip-1007-minimum-domino-rotations-for-equal-row"},"[WIP]"," 1007. Minimum Domino Rotations For Equal Row"),(0,i.kt)("h2",{id:"question"},"Question"),(0,i.kt)("p",null,"In a row of dominoes, ",(0,i.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms[i]")," represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)"),(0,i.kt)("p",null,"We may rotate the ",(0,i.kt)("inlineCode",{parentName:"p"},"ith")," domino, so that ",(0,i.kt)("inlineCode",{parentName:"p"},"tops[i]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms[i"),"] swap values."),(0,i.kt)("p",null,"Return the minimum number of rotations so that all the values in tops are the same, or all the values in ",(0,i.kt)("inlineCode",{parentName:"p"},"bottoms")," are the same."),(0,i.kt)("p",null,"If it cannot be done, return ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,i.kt)("p",null,"Example 1:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: tops = [2,1,2,4,2,2], bottoms = [5,2,6,2,3,2]\nOutput: 2\nExplanation: \nThe first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\nIf we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.\n")),(0,i.kt)("p",null,"Example 2:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: tops = [3,5,1,2,3], bottoms = [3,6,3,3,4]\nOutput: -1\nExplanation: \nIn this case, it is not possible to rotate the dominoes to make one row of values equal.\n")),(0,i.kt)("p",null,"Constraints:\n2 <= tops.length <= 2 * 104\nbottoms.length == tops.length\n1 <= tops","[i]",", bottoms","[i]"," <= 6"),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"approach"},"Approach"),(0,i.kt)("h2",{id:"solution"},"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {\n        //find rows with most common, and record the common element\n        unordered_map<int,int> topM;\n        unordered_map<int,int> bottomM;\n        int topCommon, bottomCommom;\n        int topCommonCount = 0, bottomCommomCount = 0;\n        int count = 0;\n        \n        for(int i = 0; i < tops.size(); i++){\n            topM[tops[i]]++;\n            if(topM[tops[i]] > topCommonCount){\n                topCommon = tops[i];\n                topCommonCount = topM[tops[i]];\n            } \n        }\n        \n         for(int j = 0; j < bottoms.size(); j++){\n            bottomM[bottoms[j]]++;\n            if(bottomM[bottoms[j]] > bottomCommomCount){\n                bottomCommom = bottoms[j];\n                bottomCommomCount = bottomM[bottoms[j]];\n            } \n        }\n        \n        cout << "topCommon " << topCommon << " count: " << topCommonCount << endl;\n        cout << "bottomCommon " << bottomCommom << " count: " << bottomCommomCount << endl;\n\n        if(topCommonCount >= bottomCommomCount){\n            for(int k = 0; k < tops.size(); k++){\n                if(tops[k] != topCommon){\n                    if(topCommon == bottoms[k]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n        }else {\n            for(int l = 0; l < bottoms.size(); l++){\n                if(bottoms[l] != bottomCommom){\n                    if(bottomCommom == tops[l]){\n                        count++;\n                    } else{\n                        return -1;\n                    }\n                }\n            }\n            \n        }\n        return count;\n    }\n};\n')))}p.isMDXComponent=!0}}]);